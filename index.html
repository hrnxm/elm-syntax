<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Elm Syntax</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">
	<link rel="stylesheet" href="dist/style.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/materia.min.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<svg class="elm-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 650 650">
					<path fill="rgba(255,255,255,0)" d="M0 0h600v600H0z" />
					<path fill="#1293d8"
						d="M20 599l280-280 280 280H20zM0 19l280 280L0 579V19zM320-1h280v280L320-1zm0 300l130 130 130-130-130-130-130 130zM20-1h260l122 122H142L20-1zm410 150L300 279 170 149h260zm170 430L470 449l130-130v260z" />
				</svg>
				<p class="title"><span class="elm-color">elm</span> syntax </p>
			</section>

			<section>

				<section>
					<h2> What is elm? </h2>
					<ul class="arrows">
						<li>Purely functional programming language</li>
						<li>Compiles to <span class="js-color">JavaScript</span></li>
						<li>Used for creating web browser-based GUIs</li>
					</ul>
				</section>

				<section>
					<h2> Why should I care? </h2>
					<ul class="arrows">
						<li class="fragment fade-up">Static type checking</li>
						<li class="fragment fade-up">Compiler with helpful, friendly, user messages</li>
						<li class="fragment fade-up">No runtime exceptions<span class="elm-color">!</span></li>
						<li class="fragment fade-up">Refactoring is a breeze</li>
					</ul>
				</section>

				<section>
					<h3>What does <em><span class="elm-color">purely functional</span>
						</em> even
						mean?
					</h3>

					<ul class="arrows">
						<li>Everything is a function</li>
						<li>Functions have no side effects (pure)</li>
						<li>Pure functions are easier to reason about</li>
						<li>Output based solely on input</li>
					</ul>
				</section>

				<section>
					Pure function
					<pre><code data-trim>
						function double(num) {
							return num * 2;
						}
					</code></pre>
					<div class="fragment fade-up">
						Impure functions
						<pre><code data-trim>
						function double(num) {
							return num * Math.random();
						}
						</code></pre>
						<pre class="fragment fade-up"><code data-trim>
						let numOfCalls = 0;
						
						function double(num) {
							++numOfCalls;
							launchRocket();
							return num * 2;
						}
						</code></pre>
					</div>
				</section>

				<section>
					<h3>Conclusions</h3>
					<ul>
						<li>Doesn't change external attributes of the program</li>
						<li>Same input <span class="elm-color">=</span> same output (always!) </li>
						<li>Similar to mathematical function</li>
					</ul>
				</section>

			</section>

			<section>
				<p>Everything in elm is a pure function</p>
				<p class="elm-color"> + </p>
				<p>No function overloading</p>
				<p class="elm-color"> = </p>
				<p class="fragment fade-up"> <b> Immutability </b> </p>
			</section>

			<section>

				<section>
					<h2>Types</h2>
				</section>

				<section>
					<h3>Built-in types (main ones)</h3>
					<ul>
						<li>Number: <span class="elm-color">Int</span> or <span class="elm-color">Float</span></li>
						<li><span class="elm-color">String</span></li>
						<li><span class="elm-color">Char</span></li>
						<li><span class="elm-color">Bool</span></li>
						<li><span class="elm-color">Tuple</span> (2 or 3 members)</li>
						<li><span class="elm-color">List</span> (singly-linked)</li>
						<li><span class="elm-color">Record</span> (key-value pairs)</li>
					</ul>
				</section>

				<section>
					<h3>User-defined (Unions or ADTs)</h3>
					<ul>
						<li>Keyword <span class="keyword">type</span> is used</li>
						<li>Values separated by the <span class="keyword">|</span> delimiter</li>
						<li>Names have to be unique</li>
						<pre class="elm"><code data-trim>
						type Shape = Circle | Triangle | Quad
						</code></pre>
					</ul>
				</section>

				<section>
					<pre class="elm"><code data-trim>
						-- Formatted
						type Shape 
							= Circle
							| Triangle
							| Quad
					</code></pre>
					<blockquote class="fragment fade-up">
						&ldquo;The nice thing about standards is that you have so many to choose from;&rdquo;
						<br>
						â€• Andrew S. Tanenbaum
					</blockquote>
				</section>

				<section>
					<h3>Aliasing</h3>
					<ul>
						<li>
							<span class="keyword">type alias</span> gives an additional name to an existing type
						</li>
						<li>Alias and original type are interchangeable</li>
					</ul>
					<pre class="elm"><code data-trim>
						type alias Id = String
					</code></pre>
					<div class="fragment fade-up">
						Most useful with records
						<pre class="elm"><code data-trim>
						type alias Person = 
							{ name : String, age : Int }
						</code></pre>
					</div>
					<p class="fragment fade-up">Not to be confused with <span class="keyword">type</span> keyword!</p>
				</section>

			</section>

			<section>

				<section>
					<h2>Functions</h2>
				</section>

				<section>
					<pre class="elm"><code data-trim>
					-- Declaration
					name : Par1Type -> Par2Type -> RetType
					-- Definition
					name par1 par2 =
						body
					</code></pre>
					<pre class="javascript fragment fade-up"><code data-trim>
					function name(par1, par2) {
						return /* body */
					}
					</code></pre>
				</section>

				<section>
					<pre class="elm"><code data-trim>
					add : Int -> Int -> Int
					add x y =
						x + y

					-- Invoking
					add 1 2
					</code></pre>
					<pre class="elm fragment fade-up"><code data-trim>
					-- Declaration can be ommited
					-- Compiler enforces types automatically
					add x y =
						x + y
					</code></pre>
				</section>

				<section>
					<pre class="elm"><code data-trim>
					add : Int -> Int -> Int
					add x y =
						-- Helper block
						let
							added =
								x + y
						in
						-- Still a function body
						added
					</code></pre>
					<ul class="fragment fade-up">
						<li>Functions inside <span class="keyword">let ... in</span> block behave like regular functions
						</li>
						<li>Declaration is usually ommited</li>
						<li>They're only accessible inside "parent" function</li>
					</ul>
				</section>

				<section>
					<pre class="elm"><code data-trim>
					-- Do not go too deep!
					add : Int -> Int -> String
					add x y =
						let
							stringified =
								let -- Discouraged!
									added =
										x + y
								in --
								String.fromInt added
						in
						stringified
					</code></pre>
				</section>

				<section>
					<h3>Anonymous (Lambda) functions</h3>
					<pre class="elm"><code data-trim>
					\ arg1 argN -> body
					</code></pre>
					<pre class="elm fragment fade-up"><code data-trim>
					-- Returns a list of numbers where each element is doubled
					doubled list =
						forEach list (\el -> el * 2)
					</code></pre>
				</section>

				<section>
					<h3>Higher Order Functions</h3>
					Functions that take other function(s) as argument(s), or return a function
					<pre class="elm fragment fade-up"><code data-trim data-line-numbers="1-4|6-13">
					-- There is no 'forEach' but there is 'map'

					f =
						List.map (\str -> String.toLower str) ["Hi", "Why?"]

					-- or

					f =
						let
							toLower str =
								String.toLower str
						in
						List.map toLower ["Hi", "Bye", "Why"]
					</code></pre>

				</section>

				<section>
					<p>Recongnized by parentheses in function signature</p>
					<pre class="elm fragment fade-up"><code data-trim data-line-numbers="1|2|3">
					applyAndStringify : (Int -> Int) -> Int -> String
					applyAndStringify func num =
						String.fromInt (func num)
					</code></pre>
					<p class="fragment fade-up">Parentheses can be ommited for a return value</p>
					<pre class="elm fragment fade-up"><code data-trim data-line-numbers="1-3|5-7">
					stringify : (Int -> String)
					stringify =
						String.fromInt

					stringify : Int -> String
					stringify =
						String.fromInt
					</code></pre>
					<p class="fragment fade-up">This will be important later!</p>
				</section>

			</section>

			<section>

				<section>
					<h2>Expressions</h2>
				</section>

				<section>
					<h3>if-then-else</h3>
					<pre class="elm"><code data-trim>
					isLucky num =
						if num == 7 then
							"Lucky number 7!"
						else
							"You're out of luck"
					</code></pre>
					<div class="fragment fade-up">
						<h3>Chain</h3>
						<pre class="elm"><code data-trim>
							fib n =
								if n == 0 then
									0
								else if n == 1 then
									1
								else
									fib (n - 1) + fib (n - 2)
						</code></pre>
					</div>
				</section>

				<section>
					Expression inside <em>if-then</em> MUST evaluate to Bool

					<pre class="elm"><code data-trim>
						-- Type mismatch error
						fact n =
							if n then
								n * fact (n - 1)
							else
								1
						-- Invalid expression
					</code></pre>
				</section>

				<section>
					<h3>case-of</h3>
					<pre class="elm"><code data-trim>
						stringToShape str =
							case str of
								"Circle" ->
									Circle
								"Triangle" ->
									Triangle
								"Quad" ->
									Quad
								_ ->
									Unknown
					</code></pre>
					<div class="fragment fade-up">Underscore is also used to name an unused parameter in a function
						<pre class="elm"><code data-trim>
						alwaysTrue =
							(\_ -> True)
						</code></pre>
					</div>

				</section>

				<section>
					<img src="images/case-of.svg">
				</section>

			</section>

			<section>

				<section>
					<h2>
						Parameterized type values
					</h2>
				</section>

				<section>
					<ul>
						<li>Union type values can take zero or more parameters</li>
						<pre class="elm fragment fade-up"><code data-trim>
						type User
							= Anonymous
							| Registered String
						</code></pre>
						<li class="fragment fade-up">
							They behave like constructor functions
							<pre class="elm"><code data-trim>
							> Anonymous
							function : User

							> Registered
							function : String -> User

							> Registered "Jack"
							function : User
							</code></pre>
						</li>
					</ul>
				</section>

				<section>
					Aliased records also behave like constructors
					<pre class="elm fragment fade-up"><code data-trim>
						type alias Car = 
							{ brand : String, price : Float, color : Color }
					</code></pre>
					<pre class="elm fragment fade-up"><code data-trim>
						toyota = 
							Car "Toyota" 10000 Red
					</code></pre>
					<p class="fragment fade-up">Pay attention to the order of parameters</p>
				</section>

				<section>
					Union types can be recursive
					<pre class="elm"><code data-trim>
						type Tree
							= Leaf
							| Node String Tree Tree
					</code></pre>
					<div class="fragment fade-up">
						No recursion allowed for record aliases (evauated in compile time)
						<pre class="elm"><code data-trim>
						-- Compile error
						type alias TreeNode =
							{ content : String
							, childNodes : List TreeNode
							}
					</code></pre>
					</div>
				</section>

				<section>
					Workaround?
					<div class="fragment fade-up">
						You're allowed to have union value named exacly like the type
					</div>
					<div class="fragment fade-up">
						Create a union type TreeNode, with only one value - TreeNode, parameterized with a record
					</div>
					<pre class="elm fragment fade-up"><code data-trim>
						type TreeNode
							= TreeNode
								{ content : String
								, childNodes : List TreeNode
								}
					</code></pre>
				</section>

			</section>

			<section>

				<section>
					<h2>Generics (Type Variables)</h2>
				</section>

				<section>
					<ul>
						<li>Lowercase types behave like generics</li>
						<li>Built-in (special meaning to the compiler):</li>
						<ul>
							<li><span class="elm-color">number</span> (Int and Float)</li>
							<li><span class="elm-color">comparable</span> (number, String, Char)</li>
							<li><span class="elm-color">appendable</span> (String and List) (++)</li>
							<li><span class="elm-color">compappend</span> (comparable and appendable)</li>
						</ul>
						<li>All other names are allowed</li>
					</ul>
				</section>

				<section>
					<pre class="elm"><code data-trim data-line-numbers="1|3">
					map : (a -> b) -> List a -> List b

					filter : (a -> Bool) -> List a -> List a
					</code></pre>
					<div class="fragment fade-up">
						These functions don't care about the type of data in the list, because forwarded functions know
						how to work with those types
					</div>
				</section>

				<section>
					<pre class="elm"><code data-trim>
					type Maybe a
						= Just a
						| Nothing
					</code></pre>
					<ul class="fragment fade-up">
						<li>Used daily</li>
						<li>Return value of some of the "unsafe" functions (like <span
								class="elm-color">List.head</span> )
						</li>
						<li>Also used for holding parameters that do not have "default constructor"</li>
						<li><span class="elm-color">Maybe</span> module has a number of functions that work nicely with
							this type</li>
					</ul>
				</section>

				<section>
					<h3>Extensible records</h3>
					<ul>
						<li>Describe a record that has <em>at least</em> certain field(s)</li>
						<li>Used as a parameter for a function that only needs those fields in a record</li>
						<li>Syntax is similar to a record update</li>
					</ul>
					<pre class="elm fragment fade-up"><code data-trim>
					-- Record cheat sheet

					-- Creation
					{ name = "Jack", age = 30 }

					-- Type
					{ name : String, age : Int }

					-- Update
					{ person | name = "Jackie" }

					-- Extensible
					{ named | name : String }
					</code></pre>
				</section>

			</section>

			<section>

				<section>
					<h3>Currying</h3>
					<p>and</p>
					<h3>Partial application</h3>
				</section>

				<section>
					Currying is breaking down a function that takes multiple arguments into a series of functions
					that each take only one argument
					<pre class="javascript fragment fade-up"><code data-trim data-line-numbers="1-3|4|8,14|9,13|10,12|11|15">
						function add(a, b, c) {
							return a + b + c;
						}
						add(1, 2, 3);

						// becomes

						function add(a) {
							return function(b) {
								return function(c) {
									return a + b + c; // encapsulation
								}
							}
						}
						add(1)(2)(3);
					</code></pre>
				</section>

				<section>
					Following that, <em>partial application</em> means not applying all the arguments to a curried
					function
					<pre class="javascript fragment fade-up"><code data-trim>
						function multiply(a) { // curried
							return function(b) {
								return a * b;
							}
						}
						
						function mul10() {
							return multiply(10); // partially applied
						}

						mul10(5); // => 50
					</code></pre>
				</section>

				<section>
					<ul>
						<li>Every function in elm is curried by default</li>
						<li>That's the main reason for arrows in its signature</li>
						<li>Also the reason why there is no function overload</li>
					</ul>
					<pre class="elm fragment fade-up"><code data-trim data-line-numbers="1-2|4-5|7-8|10-11|13-14">
						> Person
						function : String -> Int -> Bool -> Person
						
						> Person "Mike"
						function : Int -> Bool -> Person
						
						> Person "Mike" 30
						function : Bool -> Person
						
						> Person "Mike" 30 True
						function : Person
						
						-- Alternative signature
						function :   (String -> (Int -> (Bool -> (Person))))
					</code></pre>
					<img class="pacman" , src="images/pacman.svg">
				</section>

				<section>
					<pre class="elm"><code data-trim data-line-numbers="1-3|5-7|9-11|13-15|17-19">
						createPerson : (String -> Int -> Bool -> Person)
						createPerson =
							Person
						
						createPerson : String -> (Int -> Bool -> Person)
						createPerson name =
							Person name
						
						createPerson : String -> Int -> (Bool -> Person)
						createPerson name age =
							Person name age
						
						createPerson : String -> Int -> Bool -> (Person)
						createPerson name age isActive =
							Person name age isActive
					</code></pre>
					<div class="fragment fade-up">Parentheses are ommited in all of these cases but you should imagine
						them in your head, and for that you need to check how many function parameters are named</div>
				</section>

				<section>
					<h3>Every function in elm is higher order function</h3>
				</section>

			</section>

			<section>

				<section>
					<h3>Pipe and composition operators</h3>
				</section>

				<section>
					Pipe operators are used to avoid multiple parentheses
					They discribe data flow
					<pre class="elm"><code data-trim data-line-numbers="1|4|6|1-6">
						String.repeat 3 (String.toUpper (String.append "h" "i"))
						-- HIHIHI

						String.repeat 3 <| String.toUpper <| String.append "h" "i"

						String.append "h" "i" |> String.toUpper |> String.repeat 3
					</code></pre>
					<div class="fragment fade-up">
						<span class="elm-color">&lt|</span> - evaluate everything on the right and pipe it left
						<br>
						evaluate everything on the left and pipe it right - <span class="elm-color">|&gt</span>
					</div>
				</section>

				<section>
					Function composition is combining 2 functions in which the second one is applied to the result of
					the first one
					<div class="fragment fade-up">
						h(x) = g(f(x))
					</div>
					<pre class="elm fragment fade-up"><code data-trim>
						h = g << f
						-- or
						h = f >> g
					</code></pre>
					<pre class="elm fragment fade-up"><code data-trim>
						String.reverse >> String.lines >> List.map String.toLower
					</code></pre>
				</section>

				<section>
					Piping vs Composition
					<pre class="elm"><code data-trim>
					pipe : String -> (String)
					pipe str =
						String.reverse str |> String.left 3 |> String.toUpper
					</code></pre>
					<pre class="elm"><code data-trim>
					composition : (String -> String)
					composition =
						String.reverse >> String.left 3 >> String.toUpper
					</code></pre>
					<pre class="elm fragment fade-up"><code data-trim>
					pipe "podne" -- => "END"

					composition "podne" -- => "END"
					</code></pre>
				</section>

			</section>

			<section>
				<h2>Q <span class="elm-color">&</span> A</h2>
				<div class="github">
					<a href="https://github.com/hrnxm/elm-syntax">
						github.com / hrnxm / elm-syntax
					</a>
				</div>
			</section>

		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/zoom/zoom.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom]
		});
	</script>
</body>

</html>